'use client'

import { useEffect, useState } from 'react';
import { usePathname, useRouter } from 'next/navigation';
//import { headers, cookies } from 'next/headers'; //only works in Server Components.
import Cookies from 'js-cookie';

import { AccountRequired } from './_utils/GlobalEnumerations'; //exported within curly brackets because it's not a default export but an individual one, which is necessary in order to be able to access .Any, .Customer, .Inestor below.
import passToRequireAuth from "./_utils/RequireAuthCompositionPattern";

const account_required: AccountRequired = AccountRequired.Any; //can also be typed as 'number' since it's a numbered enum.

const Home = (props: any) => {
  //throw new Error('Error handling with error.tsx works.'); //To test how error.tsx works in app/page.tsx files.
  const pathname = usePathname();
  const router = useRouter();
  const { message } = props;
  const [ plain_text, setPlainText] = useState('');
  //Accept(only media types that the client willing to accept) can be */*(the default), application/json, text/html etc. No Content-Type because this is a GET request. Unlike Content-Type, Accept is not wrapped in quotation marks.
  const options: object = {
    method: 'POST',
    cache: 'no-cache', //force-cache is the default for NextJs and automatically caches the returned values. Others: default(if fresh, use cache if stale check server if changed, if so, fetch resource from server & update cache), no-store(fetch resource from server without checking if cached version changed, don't update cache), reload(fetch resource from server without checking if cached version changed, but update cache), no-cache(regardless of whether fresh/stale, check server if changed, if not, use cache, if so, fetch resource from server & update cache), only-if-cached(if cached, regardless of whether fresh/stale use cache. if not cached, return 504 gateway timeout error). For sensitive information, always use no-store so its not stored in cache and is always fetched directly from server & ignores cache. For constantly changing information consider using no-cache or use the default force-cache with time-based cache revalidation at short intervals.
    next: {
      revalidate: 0 //does not cache because revalidate is set to 0 seconds. Also wouldn't if caching method was no-store.
    },
    headers: {
      Accept: '*/*',
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({ //primary key 'id' is autogenerated in the server
      userId: 10,
      title: 'random title',
      body: 'Don\'t know what any of this is about'
    })
  }
  //NB: Cache revalidation can be used with any caching method(although most useful with force-cache) and also with GET/POST/PUT requests. If revalidating a POST/PUT request, make sure its idempotent.
  //NB: If revalidate is set to 0(meaning you don't want to cache) and the 'cache:' key is also used, the compiler shows an error at runtime. If revalidate is set to 0, then Next prefers for 'cache:' to be ommitted to be its default 'force-cache'.

  fetch('https://jsonplaceholder.typicode.com/posts', options)
    .then( (res) => res.json())
    .then( (data) => {
      console.log('Home', 'POST request successful');
      //console.log(data);
    }).catch( (err) => {
      console.log(err);
    });
  
  useEffect( () => {
    //The headers() function below from next/headers can only be used in a server component, not here. This function returns a read-only web headers object that allows you to access headers from incoming requests.
    //As such when sending a response from middelware to a RSC or client component, use cookies instead.
    /*let header_list: any = headers(); //ReadonlyHeaders is unresolved.

    if(header_list.has('x-message-from-middleware')) { //returns true or false.
      let message_header: string = header_list.get('x-message-from-middleware');
      console.log('Home ReadonlyHeaders', message_header);
    } else {
      console.log('Home ReadonlyHeaders', 'header not available.');
    }*/

    let cookie_value: string | undefined = Cookies.get('next_response_cookie');

    if(cookie_value !== undefined){
      //No need to JSON.parse() because the value in the cookie is a string, not a stringified JSON object.
      console.log('Home next_response_cookie', cookie_value);
      let html = 'Head <b>south</b> on <b>S Federal St</b> toward <b>W Van Buren St</b>';
      setPlainText(removeHtmlTags(html));
    } else {
      console.log('Home next_response_cookie', 'cookie not available or has expired.');
    }
  }, []);

  function removeHtmlTags(html_string: string){ //Method 1
    let div: HTMLDivElement = document.createElement('div');
    div.innerHTML = html_string;
    let text: string = div.textContent || div.innerText || '';

    return text;
  }

  function removeHtmlTagsRegEx(html_string: string){ //Method 2 using replace & RegEx.
    return html_string.replace( /(<([^>]+)>)/ig, '');
  }

  return (
    <div>
      <h1>Home ({pathname})</h1>
      <p>You should only be able to see this page if you're logged in.</p>
      <p><b>Message:</b> {message ? message : 'No message available because the message prop is only passed from /content/customers or /content/investors where <Home /> is embeded with extra props.'}</p>
      <p><b>Plain text:</b> {plain_text}</p>
    </div>
  )
}

export default passToRequireAuth(Home, account_required);
